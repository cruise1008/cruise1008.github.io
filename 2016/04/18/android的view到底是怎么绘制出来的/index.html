<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Android的view到底是怎么绘制出来的 | cruise yang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我们都知道，在android中，一个Activity对应一个PhoneWindow，而在PhoneWindow中包含一个DecorView,并且这个DecorView就是页面的顶级视图，DecorView又分为TitleActionBar和contentView,我们平常所填充的布局一般都是在content中，好，这个是大的背景知识。  
我们写了很多代码后也都会发现，其实在android中，每一">
<meta property="og:type" content="article">
<meta property="og:title" content="Android的view到底是怎么绘制出来的">
<meta property="og:url" content="http://yoursite.com/2016/04/18/android的view到底是怎么绘制出来的/index.html">
<meta property="og:site_name" content="cruise yang">
<meta property="og:description" content="我们都知道，在android中，一个Activity对应一个PhoneWindow，而在PhoneWindow中包含一个DecorView,并且这个DecorView就是页面的顶级视图，DecorView又分为TitleActionBar和contentView,我们平常所填充的布局一般都是在content中，好，这个是大的背景知识。  
我们写了很多代码后也都会发现，其实在android中，每一">
<meta property="og:updated_time" content="2016-04-28T15:33:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android的view到底是怎么绘制出来的">
<meta name="twitter:description" content="我们都知道，在android中，一个Activity对应一个PhoneWindow，而在PhoneWindow中包含一个DecorView,并且这个DecorView就是页面的顶级视图，DecorView又分为TitleActionBar和contentView,我们平常所填充的布局一般都是在content中，好，这个是大的背景知识。  
我们写了很多代码后也都会发现，其实在android中，每一">
  
    <link rel="alternative" href="/atom.xml" title="cruise yang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://raw.githubusercontent.com/cruise1008/cruise1008.github.io/master/img/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Cruise Yang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">纸上得来终觉浅，绝知此事要躬行</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">文章</a></li>
				        
							<li><a href="/tags/thoughts">随笔</a></li>
				        
							<li><a href="/about">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/cruise1008" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/cruise" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cruiseyoung" title="zhihu">zhihu</a>
					        
								<a class="douban" target="_blank" href="https://www.douban.com/people/cruiseyoung/" title="douban">douban</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Listview/" style="font-size: 10px;">Listview</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/android-View/" style="font-size: 10px;">android View</a> <a href="/tags/android-view/" style="font-size: 10px;">android view</a> <a href="/tags/android-源码/" style="font-size: 10px;">android 源码</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/java/" style="font-size: 12.5px;">java</a> <a href="/tags/java-juc/" style="font-size: 17.5px;">java juc</a> <a href="/tags/java并发/" style="font-size: 15px;">java并发</a> <a href="/tags/sdk/" style="font-size: 10px;">sdk</a> <a href="/tags/thoughts/" style="font-size: 10px;">thoughts</a> <a href="/tags/view源码/" style="font-size: 10px;">view源码</a> <a href="/tags/view绘制/" style="font-size: 10px;">view绘制</a> <a href="/tags/同步/" style="font-size: 10px;">同步</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/异步/" style="font-size: 10px;">异步</a> <a href="/tags/锁/" style="font-size: 10px;">锁</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">程序猿/足球狗/文艺工科男</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Cruise Yang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://raw.githubusercontent.com/cruise1008/cruise1008.github.io/master/img/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Cruise Yang</h1>
			</hgroup>
			
			<p class="header-subtitle">纸上得来终觉浅，绝知此事要躬行</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">文章</a></li>
		        
					<li><a href="/tags/thoughts">随笔</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/cruise1008" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/cruise" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/cruiseyoung" title="zhihu">zhihu</a>
			        
						<a class="douban" target="_blank" href="https://www.douban.com/people/cruiseyoung/" title="douban">douban</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-android的view到底是怎么绘制出来的" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/18/android的view到底是怎么绘制出来的/" class="article-date">
  	<time datetime="2016-04-18T02:11:56.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android的view到底是怎么绘制出来的
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sdk/">sdk</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view源码/">view源码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view绘制/">view绘制</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
      <p>我们都知道，在android中，一个Activity对应一个PhoneWindow，而在PhoneWindow中包含一个DecorView,并且这个DecorView就是页面的顶级视图，DecorView又分为TitleActionBar和contentView,我们平常所填充的布局一般都是在content中，好，这个是大的背景知识。  </p>
<p>我们写了很多代码后也都会发现，其实在android中，每一个布局或者视图空间都是继承View实现的，这些控件或者说布局，都是通过View的绘制机制和流程才能在手机屏幕上显示。不管是看书也好还是看网上的资料也好，我们都会被告知说android系统中一个View的成功绘制过程都必须经过measure、layout和draw三个部分。  </p>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>我们今天就来阅读源码来看看这三步到底是怎么走的。  </p>
<p>既然绘制是按照measure，layout, draw三步走的，那有个疑问是measure又是从哪过来的呢？我们这里先给出答案：  </p>
<p><strong>整个View的视图绘制过程，是从ViewRootImpl类中的performTraversals()开始的</strong>，performTraversals有上千行代码，主要是根据之前设置的状态和标记，来判断是否要重新Measure，layout和draw视图。我们看看这里的核心源码。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">	<span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">	......</span><br><span class="line">	performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">	......</span><br><span class="line">	performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">	......</span><br><span class="line">	performDraw();</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，核心的过程就是根据各种状态和条件来进行相关的绘制流程，关键代码就是上面所示，我们再看看上面列的几个的具体实现。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> measureSpec;</span><br><span class="line">	<span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">			<span class="comment">// window不能重新改变大小，必须和窗口大小一样。</span></span><br><span class="line">			measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">			<span class="comment">// Window 能更改大小，最大可以到root view的大小。</span></span><br><span class="line">			measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Window 需要指定大小。并且将root view 设为这个大小.</span></span><br><span class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要是用来测量root view的大小的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">	Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> View host = mView;</span><br><span class="line">	Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"layout"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		......</span><br><span class="line">		host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">		......</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"draw"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		draw(fullRedrawNeeded);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">		Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以看到这里，大致的流程我们就可以掌握了。  </p>
<p>从ViewRoorImpl的performTraversals()方法开始，然后通过状态标记的判断，进行performMeasure，performLayout，performDraw，分别调用view的measure, layout, draw方法进行视图的绘制。  </p>
<h1 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h1><p>既然从performTraversals开始分析到了measure, layout, draw，那我们现在就来详细看看这三个方法。  </p>
<h2 id="measure分析"><a href="#measure分析" class="headerlink" title="measure分析"></a>measure分析</h2><p>在上文讲到，在performMeasure中会调用view的measure方法。我们看看measure的方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>); <span class="comment">//当前的View控件是一个ViewGroup并且这个ViewGroup的边界模式是最佳的（刚刚好盖住一个子内容）</span></span><br><span class="line">       <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123; <span class="comment">//如果当前ViewGroup和父view的模式不一样，就裁剪一下。</span></span><br><span class="line">           Insets insets = getOpticalInsets();</span><br><span class="line">           <span class="keyword">int</span> oWidth  = insets.left + insets.right;</span><br><span class="line">           <span class="keyword">int</span> oHeight = insets.top  + insets.bottom;</span><br><span class="line">           widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</span><br><span class="line">           heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将宽高存在一个64位long 数据中，低32位的与运算是去掉高32的符号</span></span><br><span class="line">       <span class="keyword">long</span> key = (<span class="keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">       <span class="keyword">if</span> (mMeasureCache == <span class="keyword">null</span>) mMeasureCache = <span class="keyword">new</span> LongSparseLongArray(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">               widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">               heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// first clears the measured dimension flag</span></span><br><span class="line">           mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">           resolveRtlPropertiesIfNeeded();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</span><br><span class="line">                   mMeasureCache.indexOfKey(key);</span><br><span class="line">           <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">               <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">               onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">               mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">               <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">               setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">               mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125;</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">       mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line"></span><br><span class="line">       mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">               (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要是用来确定这个view到底应该多大，并且由父view提供宽高参数的限制大小的信息。也就是说每个View的实际宽高都是由父view和自身决定的。这个类是final的，也就是不能继承重写，实际的测量<br>是在第28行 onMeasure中实现的，自定义的控件或者view视图都是在onMeasure中实现，这个方法是可以重写的。  </p>
<p>我们看一下measure有两个参数，是由父视图传过来的，是父对子的一个限制信息。这个spec的int值分为两个部分，高2位表示MODE，所以最多能表示4中MODE，而实际上在MeasureSpec类中只定义了三种，即</p>
<ol>
<li>MeasureSpec.EXACTLY <em>指定了确定的大小</em></li>
<li>MeasureSpec.AT_MOST <em>最大的大小</em></li>
<li>MeasureSpec.UNSPECIFIED <em>未指定的大小</em></li>
</ol>
<p>低30位表示size，也就是父view的大小。对于DecorView的mode，一般都是MeasureSpec.EXACTLY， 而size是屏幕的宽高。对于子view来说，宽高就是父和自己一起决定的。  </p>
<p>我们看看onMeasure的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * &lt;p&gt;</span><br><span class="line">   * Measure the view and its content to determine the measured width and the</span><br><span class="line">   * measured height. This method is invoked by &#123;<span class="doctag">@link</span> #measure(int, int)&#125; and</span><br><span class="line">   * should be overridden by subclasses to provide accurate and efficient</span><br><span class="line">   * measurement of their contents.</span><br><span class="line">   * &lt;/p&gt;</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;</span><br><span class="line">   * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you</span><br><span class="line">   * &lt;em&gt;must&lt;/em&gt; call &#123;<span class="doctag">@link</span> #setMeasuredDimension(int, int)&#125; to store the</span><br><span class="line">   * measured width and height of this view. Failure to do so will trigger an</span><br><span class="line">   * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by</span><br><span class="line">   * &#123;<span class="doctag">@link</span> #measure(int, int)&#125;. Calling the superclass'</span><br><span class="line">   * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125; is a valid use.</span><br><span class="line">   * &lt;/p&gt;</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;</span><br><span class="line">   * The base class implementation of measure defaults to the background size,</span><br><span class="line">   * unless a larger size is allowed by the MeasureSpec. Subclasses should</span><br><span class="line">   * override &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125; to provide better measurements of</span><br><span class="line">   * their content.</span><br><span class="line">   * &lt;/p&gt;</span><br><span class="line">   *</span><br><span class="line">   * &lt;p&gt;</span><br><span class="line">   * If this method is overridden, it is the subclass's responsibility to make</span><br><span class="line">   * sure the measured height and width are at least the view's minimum height</span><br><span class="line">   * and width (&#123;<span class="doctag">@link</span> #getSuggestedMinimumHeight()&#125; and</span><br><span class="line">   * &#123;<span class="doctag">@link</span> #getSuggestedMinimumWidth()&#125;).</span><br><span class="line">   * &lt;/p&gt;</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> widthMeasureSpec horizontal space requirements as imposed by the parent.</span><br><span class="line">   *                         The requirements are encoded with</span><br><span class="line">   *                         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec&#125;.</span><br><span class="line">   * <span class="doctag">@param</span> heightMeasureSpec vertical space requirements as imposed by the parent.</span><br><span class="line">   *                         The requirements are encoded with</span><br><span class="line">   *                         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec&#125;.</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@see</span> #getMeasuredWidth()</span><br><span class="line">   * <span class="doctag">@see</span> #getMeasuredHeight()</span><br><span class="line">   * <span class="doctag">@see</span> #setMeasuredDimension(int, int)</span><br><span class="line">   * <span class="doctag">@see</span> #getSuggestedMinimumHeight()</span><br><span class="line">   * <span class="doctag">@see</span> #getSuggestedMinimumWidth()</span><br><span class="line">   * <span class="doctag">@see</span> android.view.View.MeasureSpec#getMode(int)</span><br><span class="line">   * <span class="doctag">@see</span> android.view.View.MeasureSpec#getSize(int)</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">      setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">              getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看看这段注释，其实写的很清楚了，就是测量视图的大小。这个方法是可以重写的。其中setMeasuredDimension是一个final方法，通过调用setMeasuredDimensionRaw来保存测量到的宽高值。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMeasuredDimension</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">		Insets insets = getOpticalInsets();</span><br><span class="line">		<span class="keyword">int</span> opticalWidth  = insets.left + insets.right;</span><br><span class="line">		<span class="keyword">int</span> opticalHeight = insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">		measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">		measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">	&#125;</span><br><span class="line">	setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setMeasuredDimension能够通过setMeasuredDimensionRaw对mMeasuredWidth和mMeasuredHeight变量赋值。我们measure的主要目的就是对View树中的每个View的mMeasuredWidth和mMeasuredHeight进行赋值，所以当这两个变量被赋值意味着该View的测量工作就全部完成。  </p>
<p>在这里我们还需要注意一个方法，在onMeasure中的setMeasuredDimension中传入的参数，是通过getDefaultSize获取的一个默认大小。我们看看getDefaultSize。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = size;</span><br><span class="line">	<span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">	<span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">	<span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">		result = size;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">	<span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">		result = specSize;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，specMode等于AT_MOST或EXACTLY就返回specSize，等于UNSPECIFIED就返回size。这些就是系统默认的尺寸。<br>回头看onMeasure方法，其中getDefaultSize参数的widthMeasureSpec和heightMeasureSpec都是由父View丢过来的。getSuggestedMinimumWidth与getSuggestedMinimumHeight都是View的方法，我们可以看看。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法分别是返回建议视图需要使用的最小宽高，并且这两个宽高是由背景尺寸和设置的最小宽（或高）共同决定的。  </p>
<p>如果一个view不再是ViewGroup，那么通过这一步就可以得到view的测量的大小，如果是viewGroup，还需要进一步测量子view的大小。  </p>
<p>当一个view是一个viewGroup,那么会走到measureChildren方法，主要就是通过一个循环来要求所有children测量自己的大小。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">	<span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">		<span class="keyword">final</span> View child = children[i];</span><br><span class="line">		<span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">			measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当中还传入了一个widthMeasureSpec和heightMeasureSpec。这就是对这个子view的宽高的要求。我们继续看到measureChild.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">		mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">		mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">	child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed, <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">		mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">		mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">	child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在这里列出了两个方法，分别是measureChild和measureChildWithMargins。其实这里的逻辑很简单，两者的区别就是measureChildWithMargins在测量时除了父视图提供的measureSpec参数外还会把margin以及<br>padding也考虑在内。而measureChild只考虑了padding。除此之外，这两个方法干的事情差不多，都是通过getChildMeasureSpec调整child的宽高的easureSpec，然后调用child视图的measure方法，也就是我们<br>之前分析的方法，去测量自身。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取父视图传来的mode和size</span></span><br><span class="line">	<span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">	<span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算size减去padding的大小，如果小于0就返回0</span></span><br><span class="line">	<span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//最后返回的结果值。</span></span><br><span class="line">	<span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">	<span class="comment">// 父视图指定了一个准确的大小</span></span><br><span class="line">	<span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">		<span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  <span class="comment">//说明开发者在xml文件或者java中设置了一个具体的大于等于0的大小值，所以将这个值设为结果，并且mode为EXACTLY.</span></span><br><span class="line">			resultSize = childDimension;</span><br><span class="line">			resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">			<span class="comment">// 子视图就设为当前值</span></span><br><span class="line">			resultSize = size;</span><br><span class="line">			resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">			<span class="comment">// 子视图自己决定大小，但是最大是当前这个值。所以mode设为AT_MOST， 大小设为size</span></span><br><span class="line">			resultSize = size;</span><br><span class="line">			resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//以下两种case的逻辑思路和上述的默认case差不多，这里就不再赘述了，大家看代码应该很容易理解。</span></span><br><span class="line">	<span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">		<span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">			resultSize = childDimension;</span><br><span class="line">			resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">			<span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">			<span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">			resultSize = size;</span><br><span class="line">			resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">			<span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">			<span class="comment">// bigger than us.</span></span><br><span class="line">			resultSize = size;</span><br><span class="line">			resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">		<span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">			resultSize = childDimension;</span><br><span class="line">			resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">			<span class="comment">// Child wants to be our size... find out how big it should be</span></span><br><span class="line">			resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">			resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">			<span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">			<span class="comment">// big it should be</span></span><br><span class="line">			resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">			resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们很容易知道，getChildMeasureSpec做的事情就是，对于传给特定子view的MeasureSpec解析出specMode和specSize，然后根据不同的mode进入不同的case，通过子view的宽高大小来计算自身正确的MeasureSpec，也就是说对这个view的宽高MeasureSpec进行调整和修改。  </p>
<p><strong>这里计算出的所有测量的结果，都是onMeasure的参数</strong>。  </p>
<p>讲到这里，我们从上面的分析可以看到，最终决定View的测量大小是View的setMeasuredDimension方法，所以我们在自定义view的时候可以直接通过setMeasuredDimension设定一个大小值来设置View的mMeasuredWidth和mMeasuredHeight的大小，但是这样缺少了灵活性，因此还是要尽量避免这种写法。  </p>
<p>另外我们还可以发现，当通过setMeasuredDimension方法最终设置完成View的measure之后View的mMeasuredWidth和mMeasuredHeight才会有真实的数值，所以如果当一个View想通过getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证这两个方法在onMeasure流程之后使用才能返回非0的值。  </p>
<p>那么回过头回到measureChild和measureChildWithMargins中，在通过getChildMeasureSpec对传入的measureSpec做出调整修改后，就会<br><em>child.measure(childWidthMeasureSpec, childHeightMeasureSpec)</em>进行正确的一个测量过程。  </p>
<h2 id="measure小结"><a href="#measure小结" class="headerlink" title="measure小结"></a>measure小结</h2><p>好了，贴了这么多代码，现在来小结一下，其实在测量过程一句话概括就是从顶层父View向子View递归调用view.measure方法，每次measure方法通过onMeasure方法进行MeasureSpec的计算。<br>几个比较重要的地方就是：</p>
<ol>
<li>MeasureSpec 一个int值。高2位模式specMode和低30位尺寸specSize组成。其中specMode有三种值：</li>
<li>MeasureSpec.EXACTLY  <em>指定了确定值，父View希望子View的大小是确定的，由specSize决定</em></li>
<li>MeasureSpec.AT_MOST <em>最大模式，父View希望子View的大小最多是specSize指定的值</em></li>
<li>MeasureSpec.UNSPECIFIED <em>未指定，父View完全依据子View的自己值来决定</em></li>
</ol>
<p>当然， </p>
<ol>
<li>另外还需要注意的是，View.measure方法是final的，不能重写，view子类只能通过重写onMeasure实现自己的测量计算逻辑。</li>
<li>最顶层DecorView测量时的MeasureSpec是由ViewRootImpl中getRootMeasureSpec方法确定的，也即是LayoutParams宽高参数均为MATCH_PARENT，specMode是EXACTLY，specSize是屏幕大小。</li>
<li>ViewGroup类需要通过一个for循环对所有的children 视图进行逐一measure。</li>
<li>ViewGroup的子类的LayoutParams必须继承MarginLayoutParams。</li>
<li>View的布局大小由父View和子View共同决定。</li>
<li>使用View的getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证这两个方法在onMeasure流之后被调用才能得到想要的结果。</li>
</ol>
<h2 id="layout分析"><a href="#layout分析" class="headerlink" title="layout分析"></a>layout分析</h2><p>在最初的背景缘起中我们看到了ViewRootImpl中的performLayout负责view的layout步骤。  </p>
<p>实际上layout的过程和measure有点类似，也是从顶层view开始一步步的往下递归，其实也就是从viewGroup一直layout到view为止的过程。好了，先说这么多，下面我们看看源码。  </p>
<p>我们看到layout时，performLayout中的关键一步是<strong>host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight())</strong>，可以看到其中传入了4个参数，分别是左上右下的四个坐标。  </p>
<p>我们先说一个结论，View的layout方法和ViewGroupLayout方法略微不太一样。由于ViewGroup是View的子类，我们先看看View的layout方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">		onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">		mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保存layout之前的四个坐标</span></span><br><span class="line">	<span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">	<span class="keyword">int</span> oldT = mTop;</span><br><span class="line">	<span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">	<span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//本质上都是通过setFrame给四个坐标参数进行复制</span></span><br><span class="line">	<span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">		<span class="comment">//关键方法</span></span><br><span class="line">		onLayout(changed, l, t, r, b); </span><br><span class="line">		mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">		ListenerInfo li = mListenerInfo;</span><br><span class="line">		<span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">			ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">			<span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">				listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">	mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中setOpticalFrame只是对parent和Child的Inset进行一个计算，最后还是调用了setFrame。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">	......</span><br><span class="line">       <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 保存drawn位</span></span><br><span class="line">           <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">           <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">           <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">           <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">           <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将旧位置置为无效</span></span><br><span class="line">           invalidate(sizeChanged);</span><br><span class="line">           <span class="comment">// 分配新的位置</span></span><br><span class="line">           mLeft = left;</span><br><span class="line">           mTop = top;</span><br><span class="line">           mRight = right;</span><br><span class="line">           mBottom = bottom;</span><br><span class="line">           mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line"></span><br><span class="line">           mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">               sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// If we are visible, force the DRAWN bit to on so that</span></span><br><span class="line">               <span class="comment">// this invalidate will go through (at least to our parent).</span></span><br><span class="line">               <span class="comment">// This is because someone may have invalidated this view</span></span><br><span class="line">               <span class="comment">// before this call to setFrame came in, thereby clearing</span></span><br><span class="line">               <span class="comment">// the DRAWN bit.</span></span><br><span class="line">               mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">               invalidate(sizeChanged);</span><br><span class="line">               <span class="comment">// 需要显示列表的父view可能因为子view的边界改变而需要重新创建</span></span><br><span class="line">               invalidateParentCaches();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 重置drawn位</span></span><br><span class="line">           mPrivateFlags |= drawn;</span><br><span class="line"></span><br><span class="line">           mBackgroundSizeChanged = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">if</span> (mForegroundInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mForegroundInfo.mBoundsChanged = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           notifySubtreeAccessibilityStateChangedIfNeeded();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在setFrame中始终是返回了changed，而changed就是根据新位置和旧位置的不同得出的。这样就可以在Veiw.layout中进行的适当的调用onLayout方法<br>以及位置更改的回调。记得这里的layout是可以重写的。<br>我们再看看View中的onLayout方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没，View中的onLayout方法是一个空方法，虽然是在layout中调用，但是需要在自定义View时自己去实现。参数就是一个changed指明当前是否是新的位置或者大小，然后需要一个相对父view的<br>四个角的位置坐标。  </p>
<p>我们再看看ViewGroup的layout方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mTransition.layoutChange(<span class="keyword">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">super</span>.layout(l, t, r, b);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// record the fact that we noop'd it; request layout when transition finishes</span></span><br><span class="line">          mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到ViewGroup的layout方法是final的，也就是子类不能重写，其中super.layout方法是走到了View.layout方法。<br>接下来看看ViewGroup的onLayout方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>什么情况？ ViewGroup的onLayout方法是抽象方法，需要在子类ViewGroup中去实现。所一个可以预期的流程就是在一个自定义的ViewGroup中，onLayout需要和onMeasure一起实现视图的布局过程。<br>当一个自定义的view通过onMeasure获得了自身和子视图的宽高大小后，就通过onLayout来进行布局，主要是对children的位置布局等一一进行摆放，一般是一个for循环进行。我们可以看看一个具体的实<br>现，我们知道LinearLayout是直接继承ViewGroup的，我们看看它是如何实现父类的抽象方法onLayout的。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">		layoutVertical(l, t, r, b);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		layoutHorizontal(l, t, r, b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑很简单，我们平常其实也是这么用的，在使用LinearLayout时必须要在xml中指定它的orientation，就是在这里进行一个判断。<br>其实这水平和竖直的onLayout也差不多，我们看看我们平常用的比较多的竖直线性布局吧。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutVertical</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> childTop;</span><br><span class="line">       <span class="keyword">int</span> childLeft;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 计算子view在右边界的位置</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> width = right - left;</span><br><span class="line">       <span class="keyword">int</span> childRight = width - mPaddingRight;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 减去左右两边的padding后子view可以利用的空闲空间</span></span><br><span class="line">       <span class="keyword">int</span> childSpace = width - paddingLeft - mPaddingRight;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> count = getVirtualChildCount(); <span class="comment">//实际是调用getChildCount方法返回的mChildrenCount,也就是这个group中子view的个数</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line">       <span class="comment">//根据majorGravity计算childTop，也就是子view的竖直的起始位置</span></span><br><span class="line">       <span class="keyword">switch</span> (majorGravity) &#123;</span><br><span class="line">          <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">              <span class="comment">// mTotalLength contains the padding already</span></span><br><span class="line">              childTop = mPaddingTop + bottom - top - mTotalLength;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// mTotalLength contains the padding already</span></span><br><span class="line">          <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">              childTop = mPaddingTop + (bottom - top - mTotalLength) / <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              childTop = mPaddingTop;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//for循环遍历子view进行位置的摆放布局</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">           <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">               childTop += measureNullChild(i);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">           	<span class="comment">//当前view为子view，此处获得了在measure过程中得到的宽高大小信息</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">               <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   gravity = minorGravity;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">               <span class="comment">//计算左边的起始位置</span></span><br><span class="line">               <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                       childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)</span><br><span class="line">                               + lp.leftMargin - lp.rightMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                       childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//可能有divider的， 也要考虑进去</span></span><br><span class="line">               <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                   childTop += mDividerHeight;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               childTop += lp.topMargin;</span><br><span class="line">               <span class="comment">//熟悉的setFrame，在这里完成位置的设置和摆放</span></span><br><span class="line">               setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);</span><br><span class="line">               childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line"></span><br><span class="line">               i += getChildrenSkipCount(child, i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>以上就是LinearLayout的onLayout的一个竖直布局的layoutVertical的过程，可以看到，主要就是对传入的四个参数（左上右下）四个位置的处理，通过一个for循环遍历ViewGroup中所有的子view，然后<br>完成各个view的位置设置。实际上中间有获取在onMeasure中测量得到的宽高信息，但是在这里并不是必须的，比如一些自定义的view的大小位置是固定的情况下。  </p>
<p>为什么说到这里就完成了布局了呢？我们看layoutVertical方法的第77行，setChildFrame方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildFrame</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">	child.layout(left, top, left + width, top + height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这一步就回到了View的layout方法，然后走到onLayout方法，这四个参数就是在layoutVertical里丢过来的左上右下四个位置坐标。就是沿着我们之前的分析了。  </p>
<h2 id="layout小结"><a href="#layout小结" class="headerlink" title="layout小结"></a>layout小结</h2><p>Layout步骤就到这儿了，逻辑还是比measure过程要简单一点的。整个过程是比较容易理解的。<br>整个过程也是和measure一样，从顶层父View向子view递归调用view的layout方法，每一层将子view放在合适的位置上。  </p>
<p>回顾起来尤其是在我们自定义view的实现时需要注意以下几个方面：  </p>
<ol>
<li>View的layout方法可被重写，但是ViewGroup的layout是final的不能被重写，ViewGroup.onLayout为abstract的，子类必须重写实现自己的布局逻辑。</li>
<li>layout操作完成之后得到的是对每个View进行位置摆放布局后的左上右下四个坐标，这些都是相对于父View的。</li>
<li>在xml等设置的layout_xx的布局属性都是的是包含当前子View的ViewGroup的设置，对自己以及对没有父view的view是没有意义的。</li>
</ol>
<h2 id="draw分析"><a href="#draw分析" class="headerlink" title="draw分析"></a>draw分析</h2><p>现在我们可以进行第三步了，draw过程。  </p>
<p>我们在本文最初有提到过，在ViewRootImpl中的performTraversals方法里，会逐步调用measure, layout, draw的步骤。关于measure, layout我们已经讲的差不多了，第三步就是draw，在<br>performTraversals里是走到了performDraw执行canvas的绘制。  </p>
<p>关于View的绘制，详细的过程可以参阅 <a href="http://icy0307.github.io/2016/04/03/sheep/" target="_blank" rel="external">方立的博客</a>， 方立秉持了处女座的追究细节的特点，<br>讲的很细，我这里就不很详细讲了，只大致讲一下过程吧。  </p>
<p>在performDraw中调用了draw(boolean fullRedrawNeeded)方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">	Surface surface = mSurface;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">final</span> Rect dirty = mDirty;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，在draw中关键一步是调用了ViewRootImpl的drawSoftware方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff, <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Canvas canvas;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">		canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">		......</span><br><span class="line">	&#125;......</span><br><span class="line">	canvas.translate(-xoff, -yoff);</span><br><span class="line">	......</span><br><span class="line">	mView.draw(canvas);</span><br><span class="line">	......</span><br><span class="line">	surface.unlockCanvasAndPost(canvas);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，在drawSoftware中调用了View的draw(Canvas canvas)方法。需要指出的是，在View中有两个draw方法，分别是</p>
<ul>
<li>draw(Canvas canvas) </li>
<li>draw(Canvas canvas, ViewGroup parent, long drawingTime)。</li>
</ul>
<p>在drawSoftware中走到的实际是draw(Canvas canvas)，另一个我们过会再看。<br>draw(Canvas canvas)的话，主要做的事情就是手动将一个已经完成了layout的view画到给定的canvas上去，在自定义view时一般不需要重写这个方法，而是用onDraw重写。</p>
<p>网上已经讨论了很多了，这里的draw主要分为6步。  </p>
<ol>
<li>画背景</li>
<li>如果必要的话，保存canvas的图层</li>
<li>画当前view的内容</li>
<li>画子view</li>
<li>如果必要的话，画渐弱边缘以及恢复图层，这一步主要是和第二步对应。</li>
<li>画一些装饰view，比如滚动条等。</li>
</ol>
<p><strong>其中2和5不是必需的</strong>。  </p>
<p>第三步画自身的内容，是通过onDraw(canvas)完成的。<br>第四步画子view，是通过dispatchDraw(canvas)完成的。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到View的onDraw是空方法，需要在自定义view时自己去实现。<br>dispatchDraw也是一个空方法，需要子类自己实现，例如ViewGroup.  </p>
<p>那我们看看ViewGroup的dispatchDraw方法。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">       <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">       ......</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">           ......</span><br><span class="line">           <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">               more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ......</span><br><span class="line">       <span class="comment">// Draw any disappearing views that have animations</span></span><br><span class="line">       <span class="keyword">if</span> (mDisappearingChildren != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ......</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = disappearingCount; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">               ......</span><br><span class="line">               more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ......</span><br><span class="line">       <span class="keyword">if</span> ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) &#123;</span><br><span class="line">           invalidate(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下ViewGroup的关键代码，主要是一个for循环遍历了所有的child视图，并且调用drawChild(canvas, child, drawingTime)方法进行每个子view的绘制。我们跟着这个走下去。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Draw one child of this View Group. This method is responsible for getting</span><br><span class="line">    * the canvas in the right state. This includes clipping, translating so</span><br><span class="line">    * that the child's scrolled origin is at 0, 0, and applying any animation</span><br><span class="line">    * transformations.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> canvas The canvas on which to draw the child</span><br><span class="line">    * <span class="doctag">@param</span> child Who to draw</span><br><span class="line">    * <span class="doctag">@param</span> drawingTime The time at which draw is occurring</span><br><span class="line">    * <span class="doctag">@return</span> True if an invalidate() was issued</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，drawChild调用了View的draw方法，但是这里调用的View的draw方法还不是我们之前分析的draw方法，而是重载的一个draw。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * This method is called by ViewGroup.drawChild() to have each child view draw itself.</span><br><span class="line"> *</span><br><span class="line"> * This is where the View specializes rendering behavior based on layer type,</span><br><span class="line"> * and hardware acceleration.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">if</span> (!drawingWithDrawingCache) &#123;</span><br><span class="line">		<span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">			mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">			((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line">			<span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">				mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">				dispatchDraw(canvas);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				draw(canvas);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个draw方法中，主要是干了两件事，一件事是对画布canvas中做了调整，多次调用了translate方法进行移动和裁剪，然后如果子视图还是ViewGroup那就走到dispatchDraw，<br>如果子视图是View，那就走到View的draw(canvas)方法。  </p>
<p>当然，<strong>这里的canvas都是ViewRootImpl中传过来的</strong>。  </p>
<p>这个draw方法只能是由ViewGroup来调用，所以本质上最后还是要走到draw(canvas)方法，然后调用onDraw方法，在传入的canvas上进行绘制。  </p>
<p>好了，draw的过程到这儿也算大致讲清楚了。之前有说，如果对具体的canvas等绘制的过程也很感兴趣，可以看看<br><a href="http://icy0307.github.io/2016/04/03/sheep/" target="_blank" rel="external">方立的博客</a> 的博客阅读。  </p>
<h2 id="draw小结"><a href="#draw小结" class="headerlink" title="draw小结"></a>draw小结</h2><p>其实这样分析下来，发现整个的逻辑流程和measure和layout是差不多的。都是从父view开始一层层往子view递归进行绘制。那么我们可以总结出什么呢？  </p>
<ol>
<li>View本身不进行绘制，绘制的内容是要在子view中进行实现的。</li>
<li>View动画和ViewGroup动画并不是一回事，View动画是自身的动画，而ViewGroup动画是显示子元素时的动画，是layoutAnimation.</li>
</ol>
<p>好了，明白了Android上的view的绘制，才能方便我们更好的去在自定义view以及一些布局的处理上有着更好的理解和实现，并且对理解其他相关机制有着更好的掌握。 </p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/28/ListView-cache-index/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          你真的了解ListView的缓存吗
        
      </div>
    </a>
  
  
    <a href="/2016/04/09/互斥锁ReentrantLock一探究竟/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">互斥锁ReentrantLock一探究竟</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="android的view到底是怎么绘制出来的" data-title="Android的view到底是怎么绘制出来的" data-url="http://yoursite.com/2016/04/18/android的view到底是怎么绘制出来的/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"cruiseyang"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Cruise Yang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>